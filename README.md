В проекте два консольных приложения: для генерации и сортировки данных.

==Generator==

Генерит файл со случайными данными для сортировки.

Параметры запуска:
- Название выходного файла
- Размер выходного файла в гигобайтах (может быть дробным числом)
- Максимальное кол-во символов в генерируемой строке
- Процент повторяющихся строк (целое число от 0 до 100)

Пример запуска из консоли с параметрами: 
**Generator.exe C:\unsorted.txt 0.1 1024 20**

==Sorter==

Сортирует строки в текстовом файле (при условии что они удовлетворяют формату '<число>. <строка>').
Строки сортируются по правилам StringComparison.Ordinal.
Числовая часть сортируется как числа (то есть '9' будет меньше чем '10')

Параметры запуска:
- Название входного файла
- Название выходного файла
- Размер буфера для работы со строками в гигобайтах (может быть дробным числом)  
    Рекомендуемое значение ~1/5 от доступной памяти.

Пример запуска из консоли с параметрами: 
**Sorter.exe C:\unsorted.txt C:\sorted.txt 0.5**

==Тесты==

SorterTests сам генерит и сортирует файл, после чего проверяет что:
- Выходной и входной файлы содержат одинаковое кол-во строк.
- Выходной файл отсортирован.
- Сортировка прошла быстрее, чем 1Gb/мин. То есть тест упадет, если на 5гб файл понадобилось больше 5 минут.

Можно поиграться, меняя настройки в методе Init.

==Описание алгоритма сортировки==

1. Разбиваем исходный файл на отсортированные подфайлы.

Считываем из исходного файла строки, пока они помещаются в буфере (объем буфера указывается при запуске алгоритма) - сортируем в памяти и записываем во временный файл. Повторяем до окончания исходного файла.

Используется параллельная сортировка, оценка сложности алгоритма в данном случае не так важна. 
Сортировка не 'in place', требует доп объема памяти. 
Похоже, что кол-во доп. памяти и эффективность алгоритма зависят от кол-ва ядер процессора (и как следствие кол-ва потоков); 

2. Объединяем отстортированные файлы.

Берем первую строку из каждого файла, сравниваем. Меньшую из строк записываем в результирующий файл, вместо нее читаем следующую и повторяем сравнение.

**Прим.** Т.к. используется внешняя сортировка, узким местом будет скорость работы с внешним хранилищем. Все остальные операции занимают меньше времени и их оптимизация не приведет к ощутимому ускорению. 
