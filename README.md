В проекте два консольных приложения: для генерации и сортировки данных.

==Generator==

Генерит файл со случайными данными для сортировки.

Параметры запуска:
- Название выходного файла
- Размер выходного файла в гигобайтах (может быть дробным числом)
- Максимальное кол-во символов в генерируемой строке
- Процент повторяющихся строк (целое число от 0 до 100)

Пример запуска из консоли с параметрами: 
**Generator.exe C:\unsorted.txt 0.1 1024 20**

==Sorter==

Сортирует строки в текстовом файле (при условии что они удовлетворяют формату '<число>. <строка>').
Строки сортируются по правилам StringComparison.Ordinal.
Числовая часть сортируется как числа (то есть '9' будет меньше чем '10')

Параметры запуска:
- Название входного файла
- Название выходного файла
- Размер буфера для работы со строками в гигобайтах (может быть дробным числом)  
    Рекомендуемое значение ~1/4 от доступной памяти.
- Количество символов в ключе при быстрой сортировке (целое число не меньше 1)
    Есть смысл увеличивать, если данные равномерно случайные и все строки начинающиеся на подстроку-ключ не помещаются в памяти.

Пример запуска из консоли с параметрами: 
**Sorter.exe C:\unsorted.txt C:\sorted.txt 0.5 1**

==Тесты==

SorterTests сам генерит и сортирует файл, после чего проверяет что:
- Выходной и входной файлы содержат одинаковое кол-во строк.
- Выходной файл отсортирован.
- Сортировка прошла быстрее, чем 1Gb/мин. То есть тест упадет, если на 5гб файл понадобилось больше 5 минут.

Можно поиграться, меняя настройки в методе Init.

==Описание алгоритма сортировки==

1. Разбиваем исходный файл на подфайлы. Сложность алгоритма - O(n).

В каждый файл записываются строки, начинающиеся с одинаковой подстроки (длина подстроки указывается при запуске алгоритма).
Т.к. все строки на "А" при сортировке будут идти раньше всех строк на "Б", получившиеся подфайлы не нужно будет сортировать между собой.

2. Сортируем каждый подфайл отдельно.

а) Если файл помещается в памяти (доступный объем памяти указывается при запуске алгоритма) - сортируем его целиком в памяти.

Алгоритм сортировки используется стандартный, встроенный в класс List. Я не замерял его эффективность, но предполагаю что его сложность O(n * log n) или близка к этому.
Если дальше развивать программу, можно ускорить внутреннюю сортировку с помощью асинхронных алгоритмов.

б) Если файл не помещается в памяти переходим к внешней (медленной) сортировке.

Делим большой файл на подфайлы, помещающиеся в памяти, сортируем их отдельно. Затем объединяем их так: берем первую строку из каждого файла, сравниваем. Меньшую из строк записываем в результирующий файл, вместо нее читаем следующую и повторяем сравнение.

Сложность алгоритма - O(n * log n) для подфайлов и O(2n) для объединения.

**Прим.** Кроме того, что объединение алгоритмически сложное, внешняя сортировка медленная из-за работы с внешним хранилищем (жесткий диск). Если большая часть файлов, полученных на первом этапе алгоритма не помещаются в памяти - лучше увеличить настройку длины подстроки.

3. Склеиваем отсортированные файлы, сложность O(n)

Берем файл со строками, начинающимися на "А", дописываем в него все строки из файла, начинающегося на "Б" и т.д. 
